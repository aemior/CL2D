#ifndef quant_ori_SCHEDULE_H
#define quant_ori_SCHEDULE_H

// MACHINE GENERATED -- DO NOT EDIT
// This schedule was automatically generated by src/AutoSchedule
// for target=x86-64-linux-avx-avx2-f16c-fma-sse41  // NOLINT
// with machine_params=16,16777216,40

#include "Halide.h"


inline void apply_schedule_quant_ori(
    ::Halide::Pipeline pipeline,
    ::Halide::Target target
) {
    using ::Halide::Func;
    using ::Halide::MemoryType;
    using ::Halide::RVar;
    using ::Halide::TailStrategy;
    using ::Halide::Var;
    Var v0_i("v0_i");
    Var v0_i_vi("v0_i_vi");
    Var v0_i_vo("v0_i_vo");
    Var v0_o("v0_o");
    Var v0_vi("v0_vi");
    Var v0_vo("v0_vo");
    Var v1_i("v1_i");
    Var v1_o("v1_o");

    Func argmax = pipeline.get_func(9);
    Func argmax_1 = pipeline.get_func(14);
    Func blur_x = pipeline.get_func(5);
    Func blur_y = pipeline.get_func(4);
    Func hist = pipeline.get_func(13);
    Func mag_out = pipeline.get_func(20);
    Func quant_res = pipeline.get_func(12);
    Func quantori = pipeline.get_func(19);
    Func soble_x = pipeline.get_func(6);
    Func soble_y = pipeline.get_func(7);

    {
        Var v0 = argmax.args()[0];
        Var v1 = argmax.args()[1];
        RVar r4$x(argmax.update(0).get_schedule().rvars()[0].var);
        argmax
            .compute_root()
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi)
            .parallel(v1);
        argmax.update(0)
            .reorder(v0, v1, r4$x)
            .split(v0, v0_vo, v0_vi, 8, TailStrategy::GuardWithIf)
            .vectorize(v0_vi)
            .reorder(r4$x, v1)
            .parallel(v1);
    }
    {
        Var v0 = argmax_1.args()[0];
        RVar r22$x(argmax_1.update(0).get_schedule().rvars()[0].var);
        argmax_1
            .compute_at(quantori, v0_o)
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi);
        argmax_1.update(0)
            .reorder(v0, v1, r22$x)
            .split(v0, v0_vo, v0_vi, 8, TailStrategy::GuardWithIf)
            .vectorize(v0_vi);
    }
    {
        Var v0 = blur_x.args()[0];
        Var v1 = blur_x.args()[1];
        Var v2 = blur_x.args()[2];
        blur_x
            .compute_root()
            .reorder(v0, v2, v1)
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi)
            .parallel(v1);
    }
    {
        Var v0 = blur_y.args()[0];
        Var v1 = blur_y.args()[1];
        blur_y
            .compute_at(blur_x, v1)
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi);
    }
    {
        Var v0 = hist.args()[0];
        RVar r17$x(hist.update(0).get_schedule().rvars()[0].var);
        RVar r17$y(hist.update(0).get_schedule().rvars()[1].var);
        hist
            .compute_at(quantori, v0_o)
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi);
        hist.update(0)
            .reorder(v0, r17$x, v1, r17$y)
            .split(v0, v0_vo, v0_vi, 8, TailStrategy::GuardWithIf)
            .vectorize(v0_vi);
    }
    {
        Var v0 = mag_out.args()[0];
        Var v1 = mag_out.args()[1];
        mag_out
            .compute_root()
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi)
            .parallel(v1);
    }
    {
        Var v0 = quant_res.args()[0];
        quant_res
            .compute_at(quantori, v0_o)
            .split(v0, v0_vo, v0_vi, 32)
            .vectorize(v0_vi);
    }
    {
        Var v0 = quantori.args()[0];
        Var v1 = quantori.args()[1];
        quantori
            .compute_root()
            .split(v0, v0_o, v0_i, 64)
            .split(v1, v1_o, v1_i, 64)
            .reorder(v0_i, v1_i, v0_o, v1_o)
            .split(v0_i, v0_i_vo, v0_i_vi, 32)
            .vectorize(v0_i_vi)
            .parallel(v1_o);
    }
    {
        Var v0 = soble_x.args()[0];
        Var v1 = soble_x.args()[1];
        Var v2 = soble_x.args()[2];
        soble_x
            .compute_root()
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi)
            .parallel(v2)
            .parallel(v1);
    }
    {
        Var v0 = soble_y.args()[0];
        Var v1 = soble_y.args()[1];
        Var v2 = soble_y.args()[2];
        soble_y
            .compute_root()
            .split(v0, v0_vo, v0_vi, 8)
            .vectorize(v0_vi)
            .parallel(v2)
            .parallel(v1);
    }


}

#endif  // quant_ori_SCHEDULE_H
